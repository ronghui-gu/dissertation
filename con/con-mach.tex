\newcommand{\PBoot}{\mathsf{PBoot}}
\newcommand{\XAsm}{\mathsf{XAsm}}

\section{Concurrent Machine Model}
\label{sec:mach}

\ignore{
\paragraph{outline} 1) C-level vs assembly-level programming
2) layer refinement for composing multiple events?
3) spinlocks (ticket lock, MCS lock)
4)thread management
5) queuing locks
6) starvation-free condition variable
}

In this section, we introduce a realistic
concurrent multiprocessor machine model $\Mach_{\boot}$,
and an assembly machine $\LAsm$ with a single active CPU
and suitable concurrent layer interfaces; then, we prove
refinement between these two machines.

\paragraph{Concurrent machine $\Mach_{\boot}$}
\ignore{$\Mach_{\boot}$} represents our model of multi-core hardware.
It captures hardware details
(\eg, addressing model),
and it supports concurrency
(\ie, arbitrary interleavings).


\textbf{The machine state} $\Mach_\boot.S = (c, f_\regs, m, a, l)$,
which consists of 
the current CPU ID $c$,
all CPUs' private states $f_\regs$
(\ie, a partial map from CPU ID to private state $\regs$),
a shared memory state $m$,
an abstract state $a$, and a global log $l$.
%The assembly language
%contains an extra register set component $regset$.
The private state $\regs$ consists of a CPU-local memory
(invisible to other CPUs) and a register set.
\ignore{

and the language dependent local components.
\ignore{The local memory is a sequence of CompCert memory blocks\ronghui{reference here, Tahina} \tahina{Do we really need to say here that we are using the CompCert memory model?},
which can be addressed by the block identifier and the offset within the block. This part of the memory is  private to a single CPU,
and are invisible to other CPUs.
The rest of the local components are language dependent.}
For instance, a C-like language consists of 
the local/temporary environment and the continuation,
while an assembly language contains the register set.
\vilhelm{This does not make sense, if we are talking about a particular machine Mboot, then there is no choice about what langauge it corresponds to?}}

The shared memory state  $m$ is \ignore{also  a sequence of
memory blocks, which are }shared among all CPUs.
Each shared memory location is associated
with a ``valid'' bit in the abstract state $a$, which can only be manipulated by 
two shared primitives called $\pull$ and $\push$. The $\pull$ operation
changes the bit from invalid to valid, after which shared memory accesses
can be performed. The $\push$ operation invalidates the bit
and records the shared memory updates to the log.
If a program tries to $\pull$ a shared memory location that is already valid,
this indicates a \emph{data race} and the machine gets \emph{stuck}.
One goal of concurrent program verification is to show
that a program is data-race free; in our setting, we accomplish 
this by showing that the program does not get stuck.

The abstract state $a$ is not just a ghost state used for reasoning.
Instead, it is abstracted from a concrete in-memory data structure,
and it can influence the outcome of program executions.
It is used both to hide implementation details and to lift reasoning
to a purely logical level. Access to an abstract state can only
be performed via explicit calls to primitives.

\ignore{
\newman{Duplicated}
, which are implemented
as Clightâ€™s external function calls. This minimizes the impact on the
semantics of C and assembly languages.
}

The global log $l$ 
is a list of events, which records all shared memory operations that affect more than
one CPU in the machine. Events generated by different CPUs are
interleaved in the log, following the actual chronological order of events.
The global log is also used as an index to query the environment context
$\oracle$, which returns the next event generated by environment CPUs.


\textbf{The transition relation} 
$\Mach_\boot.(\rightarrow)$ consists of two types of transitions: 
\emph{program transitions} and \emph{hardware scheduling}, which can 
be nondeterministically interleaved.

Program transitions can be of three types:
internal statements, private primitive calls, and shared primitive calls.
The first two types are ``local'', in that they can only access CPU-private 
state and the portion of shared memory marked as valid.
\ignore{
is denoted as $(\regs, m, a) \downarrow 
(res; \regs', m', a')$.
It says that from the private state $\regs$,
the shared memory state $m$, and the abstract
state $a$,the  execution terminates with return value
$res$, and yields the private state $\regs'$,
the memory state $m'$, and the abstract
state $a'$. Note that only the valid parts of the shared memory state can be accessed
by local steps; moreover, local primitives can only access the CPU-private state,
whereas internal statements cannot access the abstract state at all.
In both cases, the global log $l$ is unchanged.}
Shared primitives, on the other hand, provide the only means 
for accessing the global log and for generating events.
\ignore{
whose semantics is denoted
as the step relation $(args;s, res;s')$.
It says that starting from the state $s$ with the argument
$args$, the execution terminates with the state $s'$ and return
value $res$.}

A hardware scheduling transition changes the
current CPU ID $c$ to some other ID, and records this scheduling event
in the log. These transitions can be arbitrarily interleaved with
program transitions.
\ignore{In other words, at any step,
$\Mach_{\boot}$ can take either a local step,
or a hardware scheduling transition.}
\ignore{
before the execution of any local transition,
the machine can take an \emph{environment transition},
which queries the environment context $\oracle$
and updates the global log with the returned events.}

This concurrent machine model $\Mach_\boot$
reflects the nondeterministic concurrency features of 
multi-core hardware. However, since $\Mach_\boot$ allows arbitrary interleaving,
it is hard to use for program verification. Thus, we introduce
a per-core machine model $\LAsm$.

\vspace{-2pt}
\paragraph{Refinement partial machine $\PBoot$}
To make refinement proofs easier, we introduce the $\PBoot$ partial machine.
$\PBoot$ is parameterized by an environment context $\oracle$,
and machine state consists of $(c, \regs, m, a, l)$. All environment steps
are delayed until the ``point" just before the execution of shared primitives. 
This point is called a \emph{switch point}, denoted as ``$\intp$".
The transition rule at the switch point
is a big-step rule which combines many actions. First an event is
appended to the log indictating that we will interact with the
environment. Then the environment context $\oracle$ is queried
multiple times. Each time it returns an event from a CPU other than
$c$ we append that event to the log, and continue querying
$\oracle$. Finally $\oracle$ will yield back to $c$, and
the shared primitive call occurs.
The environment query is necessary before each shared primitive call because 
other CPUs must be given a chance to update shared state before the current 
CPU accesses it. Note, however, that we do not need to worry about querying
the environment at internal statements and private primitives, since
the shared state cannot influence the behavior of these
transitions. In the following, we will abuse notation and write
$l \cons \oracle(l)$ to mean the entire process of extending $l$ with
multiple events from other CPUs.

In this way, $\PBoot$ can be viewed as a partial machine
where the semantics of internal statements
and private primitives can be viewed as sequential,
and one only needs to consider concurrency
and interleaving at switch points (\ie, just before 
shared primitive calls).
This makes concurrency verification far more scalable.
\begin{lemma}\ignore{[$\Mach_\boot$ refines $\PBoot$]}
\begin{small}
$
		\Mach_\boot \refines \bigcup_{\oracle \in \mathsf{EC}(\PBoot)}{\PBoot\langle \oracle \rangle}
$
\end{small}
\ignore{
\proof
Since the internal steps and private primitives
can neither  access the global log, nor generate event,
the delay of the interleaving before them will affect neither
 the local state, nor the execution of the environment context.
 \qed}
 \label{lemma:pboot}
\end{lemma}

\ignore{
The Lemma~\ref{lemma:pboot} actually ``links'' $\PBoot$ with all
possible semantics for the hardware scheduler $hs$.}

%% Thanks to the Lemma~\ref{lemma:pboot}, the guarantees proved
%% over $\PBoot$ can be propagated down to the $\Mach_\boot$ level.

% TODO: This is wrong.
%% What's more, by the monotonicity lemma~\ref{lemma:mono},
%% we can build certified abstraction layers
%% with a single CPU $c$ on $\LAsm(L(c,\oracle))$, and compose the 
%% abstraction layers with the linking operator $\Join$.
%% In the rest of the paper, we will focus on this single-core
%% machine $\LAsm(L(c,\oracle))$.

\paragraph{Single-core assembly machine $\LAsm(L(c,\oracle))$}
Gu et al.'s $\LAsm$ assembly machine model \cite[\S 5]{dscal15} is
designed to ease sequential compositional reasoning. $\LAsm$ takes as
argument a layer interface $L := (\abst, \primt)$ where $\abst$ is the type of abstract state and
$\primt$ is the set of available primitives and their specifications.

In the concurrent setting, we can reuse $\LAsm$ with an extended
notion of layer interface, \emph{multiprocessor layer interfaces}.

\begin{definition}[Multiprocessor layer interfaces]
A multiprocessor layer interface $L := (\abst, \Ev, \primt)$ where $\abst$ is the type of abstract state, 
$\Ev$ is the type of log events, and, for any CPU identifier $c$ and environment 
context $\oracle$, $\primt(c, \oracle)$ is the set of 
available primitives and their 
specifications. We then write $L(c, \oracle) = (\abst, \primt(c, \oracle))$ to indicate the 
(single-core) layer interface for processor $c$.
Note $L[c]$ used in Sec.~\ref{sec:intro}-\ref{sec:informal}
can be viewed as a set of $L(c,\oracle)$ over any $\oracle$.  
\end{definition}

The $\LAsm(L(c, \oracle))$ machine state is thus defined as $\state:=(\regs, m, a, l)$,
where $\regs$ is the CPU-private state for CPU $c$.
We present the semantics of programs running on a single CPU in
a big-step manner.
We write $ L, M, \oracle, c \vdash f : (args;\state) \Downarrow (res;\state')$ to denote
that under the environment context $\oracle$, a function $f$ defined as either
an internal function in the module $M$ or as a primitive in the layer interface $L$,
when called with argument list $args$ from the machine state $\state$, transforms
the machine state to $\state'$ with return value ${res}$.

\textbf{Internal function} semantics are defined in terms
of execution of the function body.
\begin{small}
\[
\inferrule{
  M(f) = S \\
  \regs_0 = \regs \leftarrow args \\ 
   S : (\regs_0, m, a) \downarrow 
(res;\regs', m', a')
}{
  L, M, \oracle, c \vdash f : (args;\regs, m, a, l) \Downarrow (res;\regs', m', a', l)
}
\]
\end{small}%

\textbf{Primitive calls} simply consult the layer interface $L$
with a particular environment context $\oracle$.
\begin{small}
\[
\inferrule{
 L(c,\oracle)(f)(args;\state, res;\state')
}{
   L, M, \oracle, c \vdash f : (args;\state) \Downarrow (res;\state')
}\]
\vspace{-5pt}
\end{small}%

Since there is a switch point $\intp$ 
in front of the shared primitive,
its semantics first query the environment context $\oracle$
with the current global log $l$
and update $l$ with the returned events generated by the environment.
We also big-step this query to simplify the representation,
which means that, starting from the log $l$, $\oracle(l)$ keeps
querying and appending events until the destination
is the current CPU $c$.

In most cases, the execution of a primitive depends on what events have
been triggered at the switch point. 
For example, the $\pull$ primitive returns the
current state of the shared memory, which depends on what shared
memory updates from other CPUs are recorded in the global log.
To write the primitive specifications, we introduce an idiom of a
\textbf{replay function} $\replay$, which takes a
log as an argument, and interprets it to calculate the ``current
state'' of the system after those events have happened. The
result of the replay function can be an arbitrary type, corresponding
to what kind of information is needed about the shared operations.

For example, the replay function $\replay_{\comm{get\_shared}}$
reconstructs the shared memory state from the given log.
It first retrieves the last shared memory
update to location $b$ from the log $l$. If the last update is
$c.\pull(b)$, it returns $(\any, \comm{invalid})$, where $\any$ denotes
any possible value. The shared memory state returned in this case
does not matter since the $\pull$ operation invalidates the corresponding
memory block. On the other hand, if the last update
is $c.\push(b,\comm{bl})$ for some byte list $\bytelist$,
it returns $(\comm{bl}, \comm{valid})$. 
If there is no $\push$ or $\pull$ event in the log, it returns
$(\any, \comm{valid})$. We write ``$f\set{b:v}$"
to denote an update to the partial function $f$ at field $b$ 
with value $v$.
The rules for $\pull$ and $\push$ are defined as below:
\begin{small}
\begin{mathpar}
\inferrule{
   l_0 = l \cons \oracle(l) \\ 
  (\bytelist,  \comm{valid}) = \replay_{\comm{get\_shared}}(l_0, b) \\
  	m' = m \set{b: \bytelist} \\
  	a' = a \set{\perm{b}: \comm{valid}}  \\	
   l' = l_0 \cons c.\pull(b) \\ 
}{
 \oracle, c \vdash  \spec_{\pull}([b],\regs, m, a, l,\any, \regs,  m', a', l')
} 
\and
\inferrule{
  m(b) = \bytelist \\
  a.\perm{b} =  \comm{valid} \\
  a' = a \set{\perm{b}: \comm{invalid}} \\
  l' = l \cons  \oracle(l) \cons c.\push(b,\bytelist)   
}{
 \oracle, c \vdash  \spec_{\push}([b], \regs, m, a, l,\any, \regs, m, a', l')
}
\end{mathpar}
\vspace{-5pt}
\end{small}%

The $\pull$ operation requires the shared memory to be marked as valid
(after replaying the log). It first queries the environment context to update
the log, and then it updates the shared memory at location $b$ with the byte
list $\bytelist$ reconstructed from the log. This specification
captures the fact that the shared memory contents may be
modified by the environment context before the execution of
primitives. 
The $\push$ operation first gets the updated log from the environment context,
and then appends an event $c.\push(b,\bytelist)$ to the end of the log.
The operation is only defined when the permission bit is valid (\ie, the previous push
has already been pulled), and it invalidates the permission upon $\push$.

Let $L_0$ be the multiprocessor layer interface with the same abstract state, shared events, and primitives as in $\Mach_\boot$.
\ignore{
In general, $\LAsm(L(c, \oracle))$ is, however, not a partial machine.  For the
layer $L_0$ corresponding to primitives of $\Mach_\boot$, we have
constructed a partial machine $\XAsm(c)$ for a given core $c$ such
that:

\begin{lemma}
There exists a function $f$ such that, for any environment context $\oracle$: \[ \PBoot(\oracle) \refines \bigJoin_{c} \XAsm(c)(f(c, \oracle)) \]
\end{lemma}

\begin{lemma}
For any core $c$ and for any environment context $\oracle$: \[ \XAsm(c)(\oracle) \refines \LAsm(L_0(c, f(\oracle))) \]
\end{lemma}
\tahina{TODO: define $\XAsm$ and explain the proof}
}
Then,\ignore{For the layer $L_0$ corresponding to primitives of $\Mach_\boot$, } we
have proven that $\LAsm(L_0(c, \oracle))$ can be represented as a
partial machine, so that we can state and prove the following:
 
 \begin{lemma}
\ignore{There exists a function $f$ such that, for any environment context $\oracle$:}
{\small
$ \forall \oracle.\ \PBoot\langle \oracle \rangle \refines \bigJoin_{c\ \in\  \comm{CPU\ set}} \LAsm(L_0(c, \oracle)) $}
 \end{lemma}

