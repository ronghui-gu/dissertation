\section{Layered Concurrent Programming}
\label{sec:prog}

\ignore{
\paragraph{outline} 1) C-level vs assembly-level programming
2) layer refinement for composing multiple events?
3) spinlocks (ticket lock, MCS lock)
4)thread management
5) queuing locks
6) starvation-free condition variable
}


In this section,\ignore{we instantiate our framework with a
C-like language ClightX and an assembly level language LAsm,
and we introduce the concurrent layer interfaces for
a single active CPU.
To demonstrate the modularity and practicality of our framework
for concurrent program reasoning,}
we show how to verify spinlock implementations, shared queues protected by spinlocks,
thread scheduling primitives, and a queuing lock,
using concurrent abstraction layers.
All layers are built upon the single-core machine $\LAsm{(L(c,\oracle))}$.





\ignore{

 is a general
lock algorithm that 
allows sleeping for the lock, instead of busy waiting.
Since queuing lock
relies on the spinlocks and thread scheduling
and is implemented at C-level
(\cf Fig.~\ref{fig:exp:queue_lock}),
it is hard to reason about
and has never been verified in previous works.

In our framework, queuing lock can be easily verified
based on $L_7$.
We first introduce two atomic operations
to set the busy bit if the lock is free (\ie,
$\comm{CAS\_qlock}$, implemented
using $\comm{CAS}$),
and to clear the busy bit (\ie, $\comm{clear\_qlock}$).
Then, we prove the implementation 
of lock and unlock operations
satisfy the atomic specifications
(\ie, $\comm{acq\_q}$ and $\comm{rel\_q}$ events)
by showing the simulation relation
and the starvation-freedom.
The verification details are similar to the ticket lock.

\begin{figure}
\lstinputlisting [language = C, multicols=2] {source_code/queue_lock.c}
\vspace{-5pt}
\caption{Pseudocode of queuing lock implementation.}
\label{fig:exp:queue_lock}
\vspace{-10pt}
\end{figure}

}
